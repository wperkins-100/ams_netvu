--- Production Analysis contains many rows and columns
--- select unique customer/policy/date transactions
--- These are the basis for downstream queries


WITH ACCOUNT_HISTORY AS (
		SELECT CUSTOMER_NUMBER,
			POLICY_ID,
			POLICY_NUMBER,
			POLICY_STATUS,
			PARENT_COMPANY,
			POLICY_EFFECTIVE_DATE,
			WRITING_COMPANY,
			STRING_AGG(
				DISTINCT LINE_OF_BUSINESS_NON_PREMIUM, '; '
				ORDER BY LINE_OF_BUSINESS_NON_PREMIUM
			) AS LINE_OF_BUSINESS,
			TOTAL_COST
		FROM STAGING.PRODUCTION
		WHERE TOTAL_COST <> 0
		GROUP BY CUSTOMER_NUMBER,
			POLICY_ID,
			POLICY_NUMBER,
			POLICY_STATUS,
			PARENT_COMPANY,
			POLICY_EFFECTIVE_DATE,
			WRITING_COMPANY,
			TOTAL_COST
	),

--- Customers and every year they had a policy

	ACTIVITY AS 
	(
		SELECT DISTINCT CUSTOMER_NUMBER,
			DATE_PART('year', POLICY_EFFECTIVE_DATE) AS DT_YEAR
		FROM ACCOUNT_HISTORY
	),
	
--- Customers and the first year they had a policy

	CUSTOMERS AS 
	(
		SELECT CUSTOMER_NUMBER,
			MIN(DATE_PART('year', POLICY_EFFECTIVE_DATE)) AS DT_YEAR
		FROM ACCOUNT_HISTORY
		GROUP BY CUSTOMER_NUMBER
		--ORDER BY 1, 2
	) 
	
--- Final aggregated table for trending
--- Adapted from:
--- https: / / www.sisense.com / blog / how - TO - calculate - cohort - retention - IN - SQL /

SELECT
	b.DT_YEAR,
	b.ACTIVE_ACCOUNTS,
	b.RETAINED_ACCOUNTS,
	b.RETENTION,
	LAG(b.RETENTION) OVER(ORDER BY b.DT_YEAR) as LAG_RETENTION
FROM (

SELECT 
    A.DT_YEAR,
	COUNT(DISTINCT A.CUSTOMER_NUMBER) AS ACTIVE_ACCOUNTS,
	COUNT(DISTINCT FUTURE_ACTIVITY.CUSTOMER_NUMBER) AS RETAINED_ACCOUNTS,
	COUNT(DISTINCT FUTURE_ACTIVITY.CUSTOMER_NUMBER) / COUNT(DISTINCT A.CUSTOMER_NUMBER)::float AS RETENTION
FROM ACTIVITY A
	INNER JOIN CUSTOMERS AS U ON A.CUSTOMER_NUMBER = U.CUSTOMER_NUMBER
	AND U.DT_YEAR != A.DT_YEAR --- existing users
	-- and u.DT_YEAR = a.DT_YEAR -- new users
	LEFT JOIN ACTIVITY AS FUTURE_ACTIVITY ON A.CUSTOMER_NUMBER = FUTURE_ACTIVITY.CUSTOMER_NUMBER
	AND A.DT_YEAR = FUTURE_ACTIVITY.DT_YEAR - 1
GROUP BY 1
) b